<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eye-Tracking Fruit Ninja</title>
    <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial Black', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        #score {
            font-size: 48px;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        #calibrationOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }

        #calibrationOverlay h1 {
            font-size: 48px;
            margin-bottom: 30px;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        #calibrationOverlay p {
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
            max-width: 800px;
        }

        #startButton {
            padding: 20px 60px;
            font-size: 32px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            transition: transform 0.2s;
            font-weight: bold;
        }

        #startButton:hover {
            transform: scale(1.1);
        }

        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }

        #gameOver h1 {
            font-size: 72px;
            color: #ff3333;
            text-shadow: 0 0 30px rgba(255, 51, 51, 0.8);
            margin-bottom: 30px;
        }

        #gameOver p {
            font-size: 36px;
            margin-bottom: 40px;
        }

        #restartButton {
            padding: 20px 60px;
            font-size: 32px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            transition: transform 0.2s;
            font-weight: bold;
        }

        #restartButton:hover {
            transform: scale(1.1);
        }

        .gaze-dot {
            position: absolute;
            width: 15px;
            height: 15px;
            background: rgba(255, 255, 0, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
        }
    </style>
</head>
<body>
    <div id="calibrationOverlay">
        <h1>üçâ EYE-TRACKING FRUIT NINJA üçâ</h1>
        <p>Look at the fruits to slice them with your EYES!</p>
        <p>‚ö†Ô∏è Avoid the bombs or it's GAME OVER! ‚ö†Ô∏è</p>
        <p>üåü Special golden fruits = BONUS POINTS! üåü</p>
        <p style="font-size: 18px; margin-top: 20px; color: #aaa;">
            Please allow camera access and look at the screen for calibration
        </p>
        <button id="startButton">START CALIBRATION</button>
    </div>

    <div id="calibrationPhase" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: none; z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center;">
            <h2 style="font-size: 36px; margin-bottom: 20px; color: #ffd700;">CALIBRATION</h2>
            <p style="font-size: 24px; margin-bottom: 30px;">Look at each dot and CLICK on it</p>
            <p id="calibrationProgress" style="font-size: 20px; color: #aaa;">Point <span id="currentPoint">0</span> of 9</p>
        </div>
        <div id="calibrationDot" style="position: absolute; width: 40px; height: 40px; background: radial-gradient(circle, #ffd700 0%, #ff8c00 100%); border-radius: 50%; cursor: pointer; box-shadow: 0 0 30px rgba(255, 215, 0, 0.8); display: none; animation: pulse 0.8s infinite;"></div>
    </div>

    <style>
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
    </style>

    <div id="gameOver">
        <h1>üí• GAME OVER üí•</h1>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button id="restartButton">PLAY AGAIN</button>
    </div>

    <div id="ui">
        <div id="score">0</div>
        <div style="font-size: 18px; margin-top: 10px;">Fruits Sliced: <span id="fruitsSliced">0</span></div>
        <div style="font-size: 18px;">Difficulty: <span id="difficulty">1</span></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = 1200;
        canvas.height = 800;

        // Game state
        let gameState = {
            score: 0,
            fruitsSliced: 0,
            gameRunning: false,
            difficulty: 1,
            lastSpawnTime: 0,
            spawnInterval: 1500,
            minSpawnInterval: 400
        };

        // Eye tracking
        let gazeX = canvas.width / 2;
        let gazeY = canvas.height / 2;
        let gazeDot = null;
        let gazeSmoothing = 0.3; // Smoothing factor (0-1, lower = smoother)
        let rawGazeX = gazeX;
        let rawGazeY = gazeY;

        // Fruit types
        const fruitTypes = [
            { name: 'üçé', color: '#ff3333', points: 10 },
            { name: 'üçä', color: '#ff8c00', points: 10 },
            { name: 'üçã', color: '#ffd700', points: 10 },
            { name: 'üçå', color: '#ffff00', points: 15 },
            { name: 'üçâ', color: '#ff1493', points: 20 },
            { name: 'üçá', color: '#9370db', points: 15 },
            { name: 'ü•ù', color: '#32cd32', points: 15 },
            { name: 'üçì', color: '#ff0000', points: 10 }
        ];

        const specialFruit = { name: '‚≠ê', color: '#ffd700', points: 50 };
        const bomb = { name: 'üí£', color: '#333333', points: 0 };

        // Arrays
        let fruits = [];
        let particles = [];

        // Fruit class
        class Fruit {
            constructor(x, y, type, isSpecial = false, isBomb = false) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.isSpecial = isSpecial;
                this.isBomb = isBomb;
                this.velocityX = (Math.random() - 0.5) * 3;
                this.velocityY = -8 - Math.random() * 4;
                this.gravity = 0.15;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.1;
                this.size = 40 + Math.random() * 20;
                this.sliced = false;
            }

            update() {
                this.velocityY += this.gravity;
                this.x += this.velocityX;
                this.y += this.velocityY;
                this.rotation += this.rotationSpeed;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // Glow effect for special fruits
                if (this.isSpecial) {
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ffd700';
                }

                ctx.font = `${this.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.type.name, 0, 0);

                ctx.restore();
            }

            isPointInside(x, y) {
                const distance = Math.sqrt((x - this.x) ** 2 + (y - this.y) ** 2);
                return distance < this.size / 2;
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.velocityX = (Math.random() - 0.5) * 15;
                this.velocityY = (Math.random() - 0.5) * 15;
                this.color = color;
                this.alpha = 1;
                this.size = Math.random() * 8 + 4;
                this.decay = 0.02;
                this.gravity = 0.3;
            }

            update() {
                this.velocityY += this.gravity;
                this.x += this.velocityX;
                this.y += this.velocityY;
                this.alpha -= this.decay;
                this.size *= 0.98;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                
                // Epic glow effect
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }

            isDead() {
                return this.alpha <= 0;
            }
        }

        // Create epic slash particles
        function createSlashEffect(x, y, color, count = 40) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color));
            }

            // Add extra sparkle particles
            for (let i = 0; i < 10; i++) {
                const sparkle = new Particle(x, y, '#ffffff');
                sparkle.size = Math.random() * 3 + 2;
                sparkle.velocityX *= 2;
                sparkle.velocityY *= 2;
                particles.push(sparkle);
            }
        }

        // Spawn fruit
        function spawnFruit() {
            const x = Math.random() * (canvas.width - 100) + 50;
            const y = canvas.height + 50;

            const rand = Math.random();
            let fruit;

            if (rand < 0.05) {
                // 5% chance for special fruit
                fruit = new Fruit(x, y, specialFruit, true, false);
            } else if (rand < 0.15) {
                // 10% chance for bomb
                fruit = new Fruit(x, y, bomb, false, true);
            } else {
                // Regular fruit
                const type = fruitTypes[Math.floor(Math.random() * fruitTypes.length)];
                fruit = new Fruit(x, y, type, false, false);
            }

            fruits.push(fruit);
        }

        // Check collision with gaze
        function checkGazeCollision() {
            for (let i = fruits.length - 1; i >= 0; i--) {
                const fruit = fruits[i];
                
                if (!fruit.sliced && fruit.isPointInside(gazeX, gazeY)) {
                    fruit.sliced = true;

                    if (fruit.isBomb) {
                        // Game over!
                        endGame();
                    } else {
                        // Slice fruit
                        const points = fruit.type.points;
                        gameState.score += points;
                        gameState.fruitsSliced++;

                        // Create particles
                        createSlashEffect(fruit.x, fruit.y, fruit.type.color, fruit.isSpecial ? 80 : 40);

                        // Remove fruit
                        fruits.splice(i, 1);
                    }
                }
            }
        }

        // Update game
        function update(timestamp) {
            if (!gameState.gameRunning) return;

            // Update difficulty
            gameState.difficulty = Math.floor(gameState.fruitsSliced / 10) + 1;
            gameState.spawnInterval = Math.max(
                gameState.minSpawnInterval,
                1500 - (gameState.difficulty - 1) * 100
            );

            // Spawn fruits
            if (timestamp - gameState.lastSpawnTime > gameState.spawnInterval) {
                spawnFruit();
                gameState.lastSpawnTime = timestamp;
            }

            // Update fruits
            for (let i = fruits.length - 1; i >= 0; i--) {
                fruits[i].update();

                // Remove fruits that are off screen
                if (fruits[i].y > canvas.height + 100) {
                    fruits.splice(i, 1);
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].isDead()) {
                    particles.splice(i, 1);
                }
            }

            // Check collisions
            checkGazeCollision();

            // Update UI
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('fruitsSliced').textContent = gameState.fruitsSliced;
            document.getElementById('difficulty').textContent = gameState.difficulty;
        }

        // Render
        function draw() {
            // Clear canvas with fade effect for trail
            ctx.fillStyle = 'rgba(26, 26, 46, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw particles
            particles.forEach(particle => particle.draw());

            // Draw fruits
            fruits.forEach(fruit => fruit.draw());

            // Draw gaze indicator (subtle)
            ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(gazeX, gazeY, 30, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(gazeX, gazeY, 30, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Game loop
        function gameLoop(timestamp) {
            update(timestamp);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // End game
        function endGame() {
            gameState.gameRunning = false;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOver').style.display = 'flex';
        }

        // Start game
        function startGame() {
            gameState = {
                score: 0,
                fruitsSliced: 0,
                gameRunning: true,
                difficulty: 1,
                lastSpawnTime: 0,
                spawnInterval: 1500,
                minSpawnInterval: 400
            };

            fruits = [];
            particles = [];

            document.getElementById('calibrationOverlay').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';

            gameLoop(0);
        }

        // Calibration variables
        let calibrationPoints = [];
        let currentCalibrationPoint = 0;
        const calibrationDot = document.getElementById('calibrationDot');
        const calibrationPhase = document.getElementById('calibrationPhase');

        // Initialize WebGazer
        async function initEyeTracking() {
            try {
                // Configure WebGazer for best accuracy
                webgazer.params.showVideo = false;
                webgazer.params.showFaceOverlay = false;
                webgazer.params.showFaceFeedbackBox = false;
                webgazer.params.showGazeDot = false;
                
                // Optimize tracking parameters
                webgazer.applyKalmanFilter(true); // Smoothing filter
                webgazer.saveDataAcrossSessions(false); // Fresh calibration each time

                // Start WebGazer with best settings
                await webgazer.setRegression('ridge') // Ridge regression for accuracy
                    .setTracker('TFFacemesh') // TensorFlow face mesh
                    .begin();

                // Longer wait for better initialization
                await new Promise(resolve => setTimeout(resolve, 3000));

                // Set up gaze listener ONLY (no mouse)
                webgazer.setGazeListener((data, timestamp) => {
                    if (data) {
                        const rect = canvas.getBoundingClientRect();
                        rawGazeX = data.x - rect.left;
                        rawGazeY = data.y - rect.top;

                        // Apply smoothing (exponential moving average)
                        gazeX = gazeX * (1 - gazeSmoothing) + rawGazeX * gazeSmoothing;
                        gazeY = gazeY * (1 - gazeSmoothing) + rawGazeY * gazeSmoothing;

                        // Clamp to canvas bounds
                        gazeX = Math.max(0, Math.min(canvas.width, gazeX));
                        gazeY = Math.max(0, Math.min(canvas.height, gazeY));
                    }
                });

                console.log('Eye tracking initialized!');
            } catch (error) {
                console.error('Eye tracking error:', error);
                alert('Could not initialize eye tracking. Please check camera permissions.');
            }
        }

        // Calibration system
        function startCalibration() {
            calibrationPhase.style.display = 'block';
            
            // Define calibration points (9 points in a grid)
            calibrationPoints = [
                { x: window.innerWidth * 0.1, y: window.innerHeight * 0.1 },
                { x: window.innerWidth * 0.5, y: window.innerHeight * 0.1 },
                { x: window.innerWidth * 0.9, y: window.innerHeight * 0.1 },
                { x: window.innerWidth * 0.1, y: window.innerHeight * 0.5 },
                { x: window.innerWidth * 0.5, y: window.innerHeight * 0.5 },
                { x: window.innerWidth * 0.9, y: window.innerHeight * 0.5 },
                { x: window.innerWidth * 0.1, y: window.innerHeight * 0.9 },
                { x: window.innerWidth * 0.5, y: window.innerHeight * 0.9 },
                { x: window.innerWidth * 0.9, y: window.innerHeight * 0.9 }
            ];

            currentCalibrationPoint = 0;
            showNextCalibrationPoint();
        }

        function showNextCalibrationPoint() {
            if (currentCalibrationPoint >= calibrationPoints.length) {
                // Calibration complete
                finishCalibration();
                return;
            }

            const point = calibrationPoints[currentCalibrationPoint];
            calibrationDot.style.left = (point.x - 20) + 'px';
            calibrationDot.style.top = (point.y - 20) + 'px';
            calibrationDot.style.display = 'block';
            
            document.getElementById('currentPoint').textContent = currentCalibrationPoint + 1;
        }

        function calibrationClick(event) {
            // Record this calibration point
            const x = event.clientX;
            const y = event.clientY;
            
            // WebGazer will automatically learn from this click
            webgazer.recordScreenPosition(x, y, 'click');
            
            currentCalibrationPoint++;
            showNextCalibrationPoint();
        }

        async function finishCalibration() {
            calibrationDot.style.display = 'none';
            
            // Show completion message
            document.querySelector('#calibrationPhase > div h2').textContent = 'CALIBRATION COMPLETE!';
            document.querySelector('#calibrationPhase > div p').textContent = 'Starting game...';
            
            // Wait a moment
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            // Start the game
            calibrationPhase.style.display = 'none';
            startGame();
        }

        // Add click listener to calibration dot
        calibrationDot.addEventListener('click', calibrationClick);

        // Event listeners
        document.getElementById('startButton').addEventListener('click', async () => {
            document.getElementById('startButton').textContent = 'Initializing Camera...';
            document.getElementById('startButton').disabled = true;
            
            await initEyeTracking();
            
            // Hide initial overlay
            document.getElementById('calibrationOverlay').style.display = 'none';
            
            // Start calibration
            startCalibration();
        });

        document.getElementById('restartButton').addEventListener('click', () => {
            startGame();
        });

        // Start game loop (will only render when game is running)
        gameLoop(0);
    </script>
</body>
</html>